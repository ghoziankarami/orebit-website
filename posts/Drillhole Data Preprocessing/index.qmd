---
title: "Pre-Processing Drillhole Data for Resource Estimation"
author: "Ghozian Islam Karami"
date: "2025-09-20"
categories: [GeoDataViz, Preprocessing, Resource-Estimation]
description: "Complete workflow for transforming raw drillhole data into estimation-ready datasets using R."
image: "pre-drilling-thumb.png"
---

## Why Preprocessing Matters

**Poor preprocessing = Poor resource estimates**

Preprocessing failures account for most resource estimation errors:
- 30% grade overestimation from wrong composite lengths
- Domain boundary failures creating artificial continuity
- Outlier treatment errors causing bias

## The 4-Step Preprocessing Workflow

### Step 1: Desurveying

Transform survey data into 3D coordinates:

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(plotly)

# Sample data
collar <- tibble(
  HoleID = "DH001",
  X = 1000, Y = 2000, Z = 500
)

survey <- tibble(
  HoleID = "DH001",
  Depth = c(0, 50, 100, 150),
  Azimuth = c(0, 0, 5, 10),
  Dip = c(-90, -85, -80, -75)
)

assay <- tibble(
  HoleID = "DH001",
  From = seq(0, 145, 5),
  To = seq(5, 150, 5),
  Grade = rlnorm(30, meanlog = 0.3, sdlog = 0.6)
)

# Desurveying function
desurvey_hole <- function(collar, survey, assay) {
  
  # Interpolate survey at sample midpoints
  assay_3d <- assay %>%
    mutate(
      Midpoint = (From + To) / 2,
      # Find survey interval
      Survey_Idx = findInterval(Midpoint, survey$Depth),
      # Get survey values
      Azimuth = survey$Azimuth[pmin(Survey_Idx + 1, nrow(survey))],
      Dip = survey$Dip[pmin(Survey_Idx + 1, nrow(survey))],
      # Convert to radians
      Az_rad = Azimuth * pi / 180,
      Dip_rad = Dip * pi / 180,
      # Calculate displacement
      Length = To - From,
      DX = Length * sin(Az_rad) * cos(Dip_rad),
      DY = Length * cos(Az_rad) * cos(Dip_rad),
      DZ = Length * sin(Dip_rad)
    ) %>%
    mutate(
      # Calculate cumulative coordinates
      X = collar$X + cumsum(DX),
      Y = collar$Y + cumsum(DY),
      Z = collar$Z + cumsum(DZ)
    )
  
  return(assay_3d)
}

# Apply desurveying
desurveyed <- desurvey_hole(collar, survey, assay)

# Visualize
plot_ly(desurveyed, x = ~X, y = ~Y, z = ~Z,
        color = ~Grade, type = 'scatter3d', mode = 'markers',
        marker = list(size = 5, colorscale = 'Viridis', 
                     colorbar = list(title = "Grade"))) %>%
  layout(title = "Desurveyed Drillhole",
         scene = list(
           xaxis = list(title = "X"),
           yaxis = list(title = "Y"),
           zaxis = list(title = "Z", autorange = "reversed")
         ))
```

### Step 2: Compositing

Regularize sample lengths:

```{r}
#| label: compositing

# Compositing function (5m length)
composite_data <- function(data, comp_length = 5) {
  
  composites <- data %>%
    mutate(
      # Assign composite interval
      Comp_ID = floor(From / comp_length)
    ) %>%
    group_by(Comp_ID) %>%
    summarise(
      From = min(From),
      To = max(To),
      Length = To - From,
      Grade = weighted.mean(Grade, To - From),
      X = mean(X),
      Y = mean(Y),
      Z = mean(Z),
      N_Samples = n(),
      .groups = 'drop'
    ) %>%
    filter(Length >= comp_length * 0.5)  # Keep composites > 50% target length
  
  return(composites)
}

# Create composites
composites <- composite_data(desurveyed, comp_length = 5)

cat("Original samples:", nrow(desurveyed), "\n")
cat("Composites:", nrow(composites), "\n")
cat("Average composite length:", round(mean(composites$Length), 2), "m\n")

# Display
head(composites %>% select(Comp_ID, From, To, Length, Grade, X, Y, Z))
```

**Composite Length Selection:**
- **Too short:** Excessive smoothing, lose geological detail
- **Too long:** Sample non-stationarity, poor statistics
- **Typical:** 1-5m for most deposits

### Step 3: Outlier Treatment

Identify and handle extreme values:

```{r}
#| label: outliers
#| fig-cap: "Outlier analysis and capping"

# Calculate percentile thresholds
P95 <- quantile(composites$Grade, 0.95)
P99 <- quantile(composites$Grade, 0.99)

# Identify outliers
outlier_summary <- composites %>%
  summarise(
    Mean = mean(Grade),
    Median = median(Grade),
    P95 = P95,
    P99 = P99,
    N_Above_P95 = sum(Grade > P95),
    N_Above_P99 = sum(Grade > P99)
  )

print(outlier_summary)

# Top-cutting demonstration
composites_capped <- composites %>%
  mutate(
    Grade_Original = Grade,
    Grade_Capped = pmin(Grade, P95)  # Cap at 95th percentile
  )

# Comparison plot
p1 <- plot_ly(composites, x = ~Grade, type = "histogram", 
              name = "Original", nbinsx = 20) %>%
  layout(xaxis = list(title = "Grade"))

p2 <- plot_ly(composites_capped, x = ~Grade_Capped, type = "histogram",
              name = "Capped (P95)", nbinsx = 20) %>%
  layout(xaxis = list(title = "Grade"))

subplot(p1, p2, nrows = 2, shareX = TRUE) %>%
  layout(title = "Effect of Grade Capping")
```

**Capping Strategies:**
- **Statistical:** Percentile-based (95th, 98th)
- **Geological:** Based on domain/mineralization type
- **Spatial:** Consider outlier distribution

### Step 4: Domain Assignment

Assign samples to geological domains:

```{r}
#| label: domains

# Simple domain assignment (by elevation)
composites_domains <- composites %>%
  mutate(
    Domain = case_when(
      Z > 480 ~ "Oxide",
      Z > 460 ~ "Transition",
      TRUE ~ "Fresh"
    )
  )

# Domain statistics
domain_stats <- composites_domains %>%
  group_by(Domain) %>%
  summarise(
    N_Samples = n(),
    Mean_Grade = mean(Grade),
    SD_Grade = sd(Grade),
    Min_Grade = min(Grade),
    Max_Grade = max(Grade),
    .groups = 'drop'
  )

print(domain_stats)

# Visualize domains
plot_ly(composites_domains, x = ~X, y = ~Y, z = ~Z,
        color = ~Domain, colors = c("orange", "yellow", "green"),
        type = 'scatter3d', mode = 'markers',
        marker = list(size = 5)) %>%
  layout(title = "Geological Domains",
         scene = list(
           xaxis = list(title = "X"),
           yaxis = list(title = "Y"),
           zaxis = list(title = "Z", autorange = "reversed")
         ))
```

---

## Quality Checks Before Estimation

### Checklist:

```{r}
#| label: qa-checks

# Automated QA checks
qa_results <- list(
  "Total composites" = nrow(composites),
  "Composite length CV" = round(sd(composites$Length)/mean(composites$Length), 2),
  "Grade CV" = round(sd(composites$Grade)/mean(composites$Grade), 2),
  "Domains defined" = n_distinct(composites_domains$Domain),
  "Outliers (>P95)" = sum(composites$Grade > P95),
  "Missing coords" = sum(is.na(composites$X) | is.na(composites$Y) | is.na(composites$Z))
)

cat("QA/QC Summary:\n")
for(i in seq_along(qa_results)) {
  cat(sprintf("- %s: %s\n", names(qa_results)[i], qa_results[[i]]))
}
```

**Pass Criteria:**
- [ ] Composite length CV < 0.3
- [ ] All coordinates valid
- [ ] Outliers documented and justified
- [ ] Domains statistically different

---

## Using GeoDataViz for Preprocessing

GeoDataViz automates this entire workflow:

**Features:**
1. **Auto-desurveying:** Multiple survey interpolation methods
2. **Smart compositing:** Geological boundary preservation
3. **Outlier detection:** Multiple statistical methods
4. **Domain tools:** Interactive 3D domain definition
5. **Export:** CSV, Excel, or database formats

[**Try GeoDataViz →**](https://geodataviz.shinyapps.io/geodataviz/){.btn .btn-success target="_blank"}

---

## Next Steps

After preprocessing:
1. **Variogram Modeling** → Spatial continuity analysis
2. **Block Modeling** → Create estimation grid
3. **Kriging** → Resource estimation
4. **Validation** → Model quality checks

**Next Guide:** Coming soon - "Variogram Modeling with GeoDataViz"

---

## Summary Code

Complete preprocessing pipeline:

```{r}
#| label: summary-pipeline
#| eval: false

# Complete workflow
preprocessing_pipeline <- function(collar, survey, assay, comp_length = 5) {
  
  # 1. Desurvey
  desurveyed <- desurvey_hole(collar, survey, assay)
  
  # 2. Composite
  composites <- composite_data(desurveyed, comp_length)
  
  # 3. Cap outliers
  P95 <- quantile(composites$Grade, 0.95)
  composites$Grade_Capped <- pmin(composites$Grade, P95)
  
  # 4. Assign domains
  composites$Domain <- case_when(
    composites$Z > 480 ~ "Oxide",
    composites$Z > 460 ~ "Transition",
    TRUE ~ "Fresh"
  )
  
  return(composites)
}
```

---

*For step-by-step video tutorials, visit [@orebit.id](https://instagram.com/orebit.id)*